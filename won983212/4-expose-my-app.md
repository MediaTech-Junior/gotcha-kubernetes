# 4. 앱 외부로 노출하기

## Service

**여러 앱들을 논리적으로 묶고, 네트워크에 노출시키는 컴포넌트**입니다.

쿠버네티스에서 파드는 **일회성 자원**입니다. 파드는 언제든 다른 노드로 옮겨지거나, 삭제될 수 있어요.

파드가 매번 이렇게 바뀌면, 사용자(외부에서)는 어떻게 우리 앱에 접근해야할까요? 심지어 파드는 1개가 아닙니다. 파드가 여러 개인 경우에는 사용자는 어떤 파드로 접근해야할까요?

그래서 쿠버네티스에서는 파드를 외부에서 접근할 수 있도록 Service 컴포넌트를 제공합니다. 이 컴포넌트는...

 - **단일 진입점을 제공합니다**: 사용자가 서비스로 접근하면, 서비스는 최적의 파드로 로드벨런싱/프록싱해줍니다.
 - **외부와 통신할 수 있게 해줍니다**: 외부에서는 파드로 접근하지 않고, 서비스로 접근합니다.

### Label과 Selector

Service는 여러 파드를 묶어 외부에 노출시킵니다. 그러면 클러스터에 있는 수많은 파드들 중에서, 원하는 파드들를 어떻게 구분할까요?

바로 **Label을 사용합니다.** 파드는 여러 label을 가질 수 있습니다.

```json
"labels": {
    "app" : "spring-app-test",
    "release" : "stable",
    "environment": "dev"
}
```

이렇게 파드 별로 필요한 label들을 지정할 수 있어요. Service에서는 원하는 label을 지정하는 selector를 기입합니다.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  (...생략...)
  selector:
    app: spring-app-test
    release: stable
```


## Service Types

Service는 4개 타입이 있습니다.

### ClusterIP (기본)

ClusterIP는 파드들을 **클러스터 내부에서 통신할 수 있도록** 해줍니다. 이 Service는 클러스터 내부에서만 접근할 수 있습니다.

> ### 클러스터 내부에서만 접근할 수 있는데, 왜 쓰는거지?
> Service는 네트워크 노출뿐만 아니라, **로드벨런싱 기능**도 제공합니다. 
> 이 로드벨런싱 기능을 사용하기 위해서, 여러 파드를 service로 묶을 수 있습니다.
> 
> 일반적으로 앱은 여러 파드로 뜹니다. 그래서 service를 단순히 '_내/외부로 파드들을 노출하는 목적이다_'라고 보는 것 보다, '_앱 서비스를 이루는 연관된 파드들을 묶는 것_'이라고 보는게 맞는 것 같아요.

하지만 ClusterIP는 클러스터 내부에서만 사용할 수 있으니, 운영 용도로 사용하기에는 어려워보이네요.

### NodePort

Node의 외부에서 특정 **포트**로 들어오는 요청을, 그 포트와 연결된 Pod로 전달합니다.

이때 node는 어떤 노드든 상관 없습니다. 1번 노드의 30001포트나, 2번 노드의 30001포트나 같은 요청입니다.
즉, **포트만 정확하게** 맞추면 됩니다.

NodePort가 동작하는 원리를 좀 더 자세하게 적어보면...

1. 관리자가 30001번 포트로 NodePort를 생성한다.
2. 그러면 **ClusterIP 서비스가 같이 생성**된다.
3. 외부에서 어떤 Node의 30001포트로 보낸다. (Node는 어떤 노드든 상관 없습니다.)
4. 그 요청은 **아까 생성한 clusterIP서비스로 전달**된다.
5. ClusterIP에 의해 트래픽이 파드로 전달된다.

즉, NodePort는 결국 <u>특정 포트로 들어오는 트래픽</u>을 **ClusterIP**으로 보내주는 역할입니다.
그래서 NodePort는 ClusterIP의 기능을 모두 포함합니다.

### LoadBalancer

외부 로드벨런서(GCP, AWS, ...)에 **service를 노출하여, 클라우드 제공자에 의해 로드벨런싱**이 되도록 합니다.

NodePort는 노드의 아이피로 접속해야합니다. 그런데 AWS나 GCP를 사용하면서, 오토 스케일링 등의 이유로 노드의 네트워크 환경이 계속 바뀐다면?

이 LoadBalancer 타입의 service를 사용해서, 클라우드 제공자가 트래픽을 관리하도록 합니다. 그리고 LoadBalancer는 생성될 때 NodePort와 ClusterIP를 함께 생성합니다.

### ExternalName

위의 service들과 약간 다릅니다. ExternalName은 DNS name을 직접 명시해서, 이 service에 접근하면 그 dns name에 대한 CNAME을 반환합니다.

이 service를 생성하고, `{SERVICE_NAME}.prod.svc.cluster.local`의 호스트를 조회해보면, 지정했던 주소값이 나옵니다.
마치 DNS처럼 동작하는 서비스네요.